10:21-10:23::GrahamScan.$fEqTurn :: "(GHC.Classes.Eq GrahamScan.Turn)"
19:1-19:4::GrahamScan.ccw :: "(GHC.Types.Int, GHC.Types.Int)\n-> (GHC.Types.Int, GHC.Types.Int)\n-> (GHC.Types.Int, GHC.Types.Int)\n-> GHC.Types.Double"
20:3-20:15::lq_anf__d1U9 :: "x1:GHC.Types.Int -> {v : GHC.Types.Double | v == x1}"
20:16-20:17::_ :: "(GHC.Types.Int -> GHC.Types.Double)\n-> GHC.Types.Int -> GHC.Types.Double"
20:18-20:35::lq_anf__d1Uc :: "GHC.Types.Int"
20:19-20:21::x2 :: "GHC.Types.Int"
20:21-20:22::_ :: "x1:GHC.Types.Int\n-> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 - x2}"
20:22-20:24::x1 :: "{v : GHC.Types.Int | v == x1}"
20:26-20:27::_ :: "x1:GHC.Types.Int\n-> x2:GHC.Types.Int\n-> {v : GHC.Types.Int | x1 > 0 && x2 > 0 => v >= x1 && v >= x2 && x1 > 1 && x2 > 1 => v > x1 && v > x2 && x1 == 0 || x2 == 0 => v == 0}"
20:29-20:31::y3 :: "{v : GHC.Types.Int | v == y3}"
20:31-20:32::_ :: "x1:GHC.Types.Int\n-> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 - x2}"
20:32-20:34::y1 :: "{v : GHC.Types.Int | v == y1}"
20:36-20:37::_ :: "x1:GHC.Types.Int\n-> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 - x2}"
20:38-20:55::lq_anf__d1Uf :: "GHC.Types.Int"
20:39-20:41::y2 :: "{v : GHC.Types.Int | v == y2}"
20:41-20:42::_ :: "x1:GHC.Types.Int\n-> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 - x2}"
20:42-20:44::y1 :: "{v : GHC.Types.Int | v == y1}"
20:46-20:47::_ :: "x1:GHC.Types.Int\n-> x2:GHC.Types.Int\n-> {v : GHC.Types.Int | x1 > 0 && x2 > 0 => v >= x1 && v >= x2 && x1 > 1 && x2 > 1 => v > x1 && v > x2 && x1 == 0 || x2 == 0 => v == 0}"
20:49-20:51::x3 :: "{v : GHC.Types.Int | v == x3}"
20:51-20:52::_ :: "x1:GHC.Types.Int\n-> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 - x2}"
20:52-20:54::x1 :: "{v : GHC.Types.Int | v == x1}"
23:1-23:9::GrahamScan.whichWay :: "GHC.Types.Double -> GrahamScan.Turn"
23:10-23:13::ccw :: "GHC.Types.Double"
24:5-24:8::ccw :: "{v : GHC.Types.Double | v == ccw}"
24:9-24:10::_ :: "x1:GHC.Types.Double\n-> x2:GHC.Types.Double -> {v : GHC.Types.Bool | Prop v <=> x1 < v}"
24:11-24:12::lq_anf__d1TV :: "{v : GHC.Types.Double | v == 0.0}"
24:17-24:19::GrahamScan.CW :: "{v : GrahamScan.Turn | v == GrahamScan.CW}"
25:5-25:8::ccw :: "{v : GHC.Types.Double | v == ccw}"
25:9-25:10::_ :: "x1:GHC.Types.Double\n-> x2:GHC.Types.Double -> {v : GHC.Types.Bool | Prop v <=> x1 > v}"
25:11-25:12::lq_anf__d1TY :: "{v : GHC.Types.Double | v == 0.0}"
25:17-25:20::GrahamScan.CCW :: "{v : GrahamScan.Turn | v == GrahamScan.CCW}"
26:17-26:19::_ :: "{v : GrahamScan.Turn | v == GrahamScan.CL}"
29:1-29:11::GrahamScan.sortByYMin :: "[(GHC.Types.Int, GHC.Types.Int)]\n-> [(GHC.Types.Int, GHC.Types.Int)]"
29:14-29:20::_ :: "((GHC.Types.Int, GHC.Types.Int)\n -> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Ordering)\n-> [(GHC.Types.Int, GHC.Types.Int)]\n-> [(GHC.Types.Int, GHC.Types.Int)]"
29:21-29:29::lq_anf__d1U5 :: "(GHC.Types.Int, GHC.Types.Int)\n-> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Ordering"
31:5-31:13::compareY :: "forall a b.\n(GHC.Classes.Ord [Bivariant]\n[] b, GHC.Classes.Ord [Bivariant]\n[] a) =>\n(a, b) -> (a, b) -> GHC.Types.Ordering"
32:9-32:11::y1 :: "{VV : a | VV == y1}"
32:12-32:14::_ :: "x1:a -> x2:a -> {v : GHC.Types.Bool | Prop v <=> x1 == v}"
32:15-32:17::y2 :: "{VV : a | VV == y2}"
32:20-32:27::_ :: "x1:a\n-> x2:a\n-> {v : GHC.Types.Ordering | v == GHC.Types.EQ <=> x1 == x2 && v == GHC.Types.GT <=> x1 > x2 && v == GHC.Types.LT <=> x1 < x2}"
32:28-32:30::x1 :: "{VV : a | VV == x1}"
32:31-32:33::x2 :: "{VV : a | VV == x2}"
33:21-33:28::_ :: "x1:a\n-> x2:a\n-> {v : GHC.Types.Ordering | v == GHC.Types.EQ <=> x1 == x2 && v == GHC.Types.GT <=> x1 > x2 && v == GHC.Types.LT <=> x1 < x2}"
33:29-33:31::y1 :: "{VV : a | VV == y1}"
33:32-33:34::y2 :: "{VV : a | VV == y2}"
36:1-36:9::GrahamScan.orderCCW :: "(GHC.Types.Int, GHC.Types.Int)\n-> (GHC.Types.Int, GHC.Types.Int)\n-> (GHC.Types.Int, GHC.Types.Int)\n-> GHC.Types.Ordering"
36:10-36:12::mp :: "(GHC.Types.Int, GHC.Types.Int)"
36:13-36:15::p1 :: "(GHC.Types.Int, GHC.Types.Int)"
36:16-36:18::p2 :: "(GHC.Types.Int, GHC.Types.Int)"
36:25-36:28::ord :: "GHC.Types.Ordering"
36:31-36:38::_ :: "x1:GHC.Types.Double\n-> x2:GHC.Types.Double\n-> {v : GHC.Types.Ordering | v == GHC.Types.EQ <=> x1 == x2 && v == GHC.Types.GT <=> x1 > x2 && v == GHC.Types.LT <=> x1 < x2}"
36:40-36:43::_ :: "(GHC.Types.Int, GHC.Types.Int)\n-> (GHC.Types.Int, GHC.Types.Int)\n-> (GHC.Types.Int, GHC.Types.Int)\n-> GHC.Types.Double"
36:44-36:46::mp :: "{v : (GHC.Types.Int, GHC.Types.Int) | v == mp}"
36:47-36:49::p1 :: "{v : (GHC.Types.Int, GHC.Types.Int) | v == p1}"
36:50-36:52::p2 :: "{v : (GHC.Types.Int, GHC.Types.Int) | v == p2}"
36:54-36:55::lq_anf__d1UB :: "{v : GHC.Types.Double | v == 0.0}"
37:27-37:30::_ :: "{v : GHC.Types.Ordering | v == ord}"
38:29-38:36::_ :: "x1:GHC.Types.Double\n-> x2:GHC.Types.Double\n-> {v : GHC.Types.Ordering | v == GHC.Types.EQ <=> x1 == x2 && v == GHC.Types.GT <=> x1 > x2 && v == GHC.Types.LT <=> x1 < x2}"
38:38-38:42::_ :: "(GHC.Types.Int, GHC.Types.Int)\n-> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Double"
38:43-38:45::mp :: "{v : (GHC.Types.Int, GHC.Types.Int) | v == mp}"
38:46-38:48::p1 :: "{v : (GHC.Types.Int, GHC.Types.Int) | v == p1}"
38:51-38:55::_ :: "(GHC.Types.Int, GHC.Types.Int)\n-> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Double"
38:56-38:58::mp :: "{v : (GHC.Types.Int, GHC.Types.Int) | v == mp}"
38:59-38:61::p2 :: "{v : (GHC.Types.Int, GHC.Types.Int) | v == p2}"
39:29-39:32::_ :: "{v : GHC.Types.Ordering | v == ord}"
42:1-42:11::GrahamScan.grahamScan :: "[(GHC.Types.Int, GHC.Types.Int)]\n-> [(GHC.Types.Int, GHC.Types.Int)]"
42:12-42:15::ps' :: "[(GHC.Types.Int, GHC.Types.Int)]"
42:18-42:21::_ :: "(((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)\n -> (GHC.Types.Int, GHC.Types.Int))\n-> x3:[((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)]\n-> {v : [(GHC.Types.Int, GHC.Types.Int)] | len v == len x3}"
42:22-42:25::lq_anf__d1UN :: "((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)\n-> (GHC.Types.Int, GHC.Types.Int)"
42:26-42:27::_ :: "([((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)]\n -> [(GHC.Types.Int, GHC.Types.Int)])\n-> [((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)]\n-> [(GHC.Types.Int, GHC.Types.Int)]"
42:28-42:34::_ :: "(((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)\n -> GHC.Types.Bool)\n-> x3:[((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)]\n-> {v : [((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)] | len v <= len x3}"
42:36-42:54::lq_anf__d1UQ :: "((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn) -> GHC.Types.Bool"
42:47-42:48::t :: "{v : GrahamScan.Turn | v == t}"
42:49-42:51::GrahamScan.$fEqTurn :: "(GHC.Classes.Eq GrahamScan.Turn)"
42:52-42:54::GrahamScan.CW :: "{v : GrahamScan.Turn | v == GrahamScan.CW}"
42:56-42:57::_ :: "([((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)]\n -> [((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)])\n-> [((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)]\n-> [((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)]"
42:58-42:63::_ :: "[(GHC.Types.Int, GHC.Types.Int)]\n-> [((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)]"
42:64-42:71::sorteds :: "{v : [(GHC.Types.Int, GHC.Types.Int)] | null v <=> false && v == sorteds && xListSelector v == minP && len v >= 0}"
44:5-44:7::ps :: "[(GHC.Types.Int, GHC.Types.Int)]"
44:10-44:13::_ :: "[(GHC.Types.Int, GHC.Types.Int)]\n-> [(GHC.Types.Int, GHC.Types.Int)]"
44:14-44:17::ps' :: "{v : [(GHC.Types.Int, GHC.Types.Int)] | v == ps' && len v >= 0}"
45:5-45:9::minP :: "(GHC.Types.Int, GHC.Types.Int)"
45:10-45:14::mins :: "[(GHC.Types.Int, GHC.Types.Int)]"
45:17-45:27::_ :: "[(GHC.Types.Int, GHC.Types.Int)]\n-> [(GHC.Types.Int, GHC.Types.Int)]"
45:28-45:30::ps :: "{v : [(GHC.Types.Int, GHC.Types.Int)] | v == ps && len v >= 0}"
46:5-46:12::sorteds :: "{v : [(GHC.Types.Int, GHC.Types.Int)] | null v <=> false && xListSelector v == minP}"
46:15-46:19::minP :: "{v : (GHC.Types.Int, GHC.Types.Int) | v == minP}"
46:20-46:21::_ :: "x1:(GHC.Types.Int, GHC.Types.Int)\n-> x2:[(GHC.Types.Int, GHC.Types.Int)]\n-> {v : [(GHC.Types.Int, GHC.Types.Int)] | null v <=> false && xListSelector v == x1 && len v == 1 + len x2 && xsListSelector v == x2}"
46:22-46:28::_ :: "((GHC.Types.Int, GHC.Types.Int)\n -> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Ordering)\n-> [(GHC.Types.Int, GHC.Types.Int)]\n-> [(GHC.Types.Int, GHC.Types.Int)]"
46:30-46:38::_ :: "(GHC.Types.Int, GHC.Types.Int)\n-> (GHC.Types.Int, GHC.Types.Int)\n-> (GHC.Types.Int, GHC.Types.Int)\n-> GHC.Types.Ordering"
46:39-46:43::minP :: "{v : (GHC.Types.Int, GHC.Types.Int) | v == minP}"
46:45-46:49::mins :: "{v : [(GHC.Types.Int, GHC.Types.Int)] | v == mins && len v >= 0}"
48:1-48:6::GrahamScan.turns :: "[(GHC.Types.Int, GHC.Types.Int)]\n-> [((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)]"
48:30-48:59::lq_anf__d1Um :: "{v : ((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn) | fst v == p2 && x_Tuple21 v == p2}"
48:31-48:33::p2 :: "{v : (GHC.Types.Int, GHC.Types.Int) | v == p2}"
48:35-48:43::GrahamScan.whichWay :: "GHC.Types.Double -> GrahamScan.Turn"
48:44-48:45::_ :: "(GHC.Types.Double -> GrahamScan.Turn)\n-> GHC.Types.Double -> GrahamScan.Turn"
48:46-48:49::_ :: "(GHC.Types.Int, GHC.Types.Int)\n-> (GHC.Types.Int, GHC.Types.Int)\n-> (GHC.Types.Int, GHC.Types.Int)\n-> GHC.Types.Double"
48:50-48:52::p1 :: "{v : (GHC.Types.Int, GHC.Types.Int) | v == p1}"
48:53-48:55::p2 :: "{v : (GHC.Types.Int, GHC.Types.Int) | v == p2}"
48:56-48:58::p3 :: "{v : (GHC.Types.Int, GHC.Types.Int) | v == p3}"
48:60-48:61::_ :: "x1:((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)\n-> x2:[((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)]\n-> {v : [((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)] | null v <=> false && xListSelector v == x1 && len v == 1 + len x2 && xsListSelector v == x2}"
48:62-48:67::GrahamScan.turns :: "[(GHC.Types.Int, GHC.Types.Int)]\n-> [((GHC.Types.Int, GHC.Types.Int), GrahamScan.Turn)]"
48:68-48:72::lq_anf__d1Ui :: "{v : [(GHC.Types.Int, GHC.Types.Int)] | null v <=> false && v == rest && xListSelector v == p2 && len v >= 0}"
49:30-49:32::GHC.Types.[] :: "forall a <p :: a a -> Prop>.\n{v : [a]<\\x4 VV -> p x4> | null v <=> true && len v == 0}"
52:1-52:5::GrahamScan.dist :: "(GHC.Types.Int, GHC.Types.Int)\n-> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Double"
53:7-53:9::dx :: "GHC.Types.Double"
53:12-53:24::lq_anf__d1Us :: "x1:GHC.Types.Int -> {v : GHC.Types.Double | v == x1}"
53:25-53:26::_ :: "(GHC.Types.Int -> GHC.Types.Double)\n-> GHC.Types.Int -> GHC.Types.Double"
53:27-53:29::x2 :: "GHC.Types.Int"
53:29-53:30::_ :: "x1:GHC.Types.Int\n-> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 - x2}"
53:30-53:32::x1 :: "{v : GHC.Types.Int | v == x1}"
54:7-54:9::dy :: "GHC.Types.Double"
54:12-54:24::lq_anf__d1Uq :: "x1:GHC.Types.Int -> {v : GHC.Types.Double | v == x1}"
54:25-54:26::_ :: "(GHC.Types.Int -> GHC.Types.Double)\n-> GHC.Types.Int -> GHC.Types.Double"
54:27-54:29::y2 :: "{v : GHC.Types.Int | v == y2}"
54:29-54:30::_ :: "x1:GHC.Types.Int\n-> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 - x2}"
54:30-54:32::y1 :: "{v : GHC.Types.Int | v == y1}"
55:3-55:7::lq_anf__d1Uu :: "GHC.Types.Double -> GHC.Types.Double"
55:8-55:9::_ :: "(GHC.Types.Double -> GHC.Types.Double)\n-> GHC.Types.Double -> GHC.Types.Double"
55:10-55:25::lq_anf__d1Uz :: "GHC.Types.Double"
55:11-55:13::dx :: "{v : GHC.Types.Double | v == dx}"
55:13-55:14::_ :: "GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double"
55:17-55:18::_ :: "x1:GHC.Types.Double\n-> x2:GHC.Types.Double -> {v : GHC.Types.Double | v == x1 + x2}"
55:20-55:22::dy :: "{v : GHC.Types.Double | v == dy}"
55:22-55:23::_ :: "GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double"
58:1-58:10::GrahamScan.perimeter :: "[(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Double"
58:11-58:13::ps :: "[(GHC.Types.Int, GHC.Types.Int)]"
58:20-58:22::qs :: "[(GHC.Types.Int, GHC.Types.Int)]"
58:25-58:29::_ :: "x1:{v : [(GHC.Types.Int, GHC.Types.Int)] | len v > 0}\n-> {v : [(GHC.Types.Int, GHC.Types.Int)] | len v == len x1 - 1}"
58:30-58:32::ps :: "{v : [(GHC.Types.Int, GHC.Types.Int)] | v == ps && len v >= 0}"
58:33-58:35::_ :: "x1:[(GHC.Types.Int, GHC.Types.Int)]\n-> x2:[(GHC.Types.Int, GHC.Types.Int)]\n-> {v : [(GHC.Types.Int, GHC.Types.Int)] | len v == len x1 + len v}"
58:36-58:45::lq_anf__d1UX :: "{v : [(GHC.Types.Int, GHC.Types.Int)] | null v <=> false && len v >= 0}"
58:37-58:41::_ :: "{v : [(GHC.Types.Int, GHC.Types.Int)] | len v > 0}\n-> (GHC.Types.Int, GHC.Types.Int)"
58:42-58:44::ps :: "{v : [(GHC.Types.Int, GHC.Types.Int)] | v == ps && len v >= 0}"
59:17-59:20::lq_anf__d1UY :: "[GHC.Types.Double] -> GHC.Types.Double"
59:21-59:22::_ :: "([GHC.Types.Double] -> GHC.Types.Double)\n-> [GHC.Types.Double] -> GHC.Types.Double"
59:23-59:30::_ :: "((GHC.Types.Int, GHC.Types.Int)\n -> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Double)\n-> x4:[(GHC.Types.Int, GHC.Types.Int)]\n-> x5:[(GHC.Types.Int, GHC.Types.Int)]\n-> {v : [GHC.Types.Double] | len v <= len x4 && len v <= len x5}"
59:31-59:35::GrahamScan.dist :: "(GHC.Types.Int, GHC.Types.Int)\n-> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Double"
59:36-59:38::ps :: "{v : [(GHC.Types.Int, GHC.Types.Int)] | v == ps && len v >= 0}"
59:39-59:41::qs :: "{v : [(GHC.Types.Int, GHC.Types.Int)] | v == qs && len v >= 0}"
62:1-62:6::GrahamScan.solve :: "[(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Double"
62:9-62:18::GrahamScan.perimeter :: "[(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Double"
62:19-62:20::_ :: "([(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Double)\n-> ([(GHC.Types.Int, GHC.Types.Int)]\n    -> [(GHC.Types.Int, GHC.Types.Int)])\n-> [(GHC.Types.Int, GHC.Types.Int)]\n-> exists [[(GHC.Types.Int, GHC.Types.Int)]].GHC.Types.Double"
62:21-62:31::GrahamScan.grahamScan :: "[(GHC.Types.Int, GHC.Types.Int)]\n-> [(GHC.Types.Int, GHC.Types.Int)]"
65:1-65:5::GrahamScan.main :: "(GHC.Types.IO ())"
66:3-66:4::n :: "GHC.Types.Int"
66:8-66:14::lq_anf__d1V0 :: "(GHC.Types.IO GHC.Types.Int)"
67:3-67:10::content :: "[GHC.Types.Char]"
67:14-67:25::System.IO.getContents :: "{v : (GHC.Types.IO [GHC.Types.Char]) | v == System.IO.getContents}"
69:5-69:11::points :: "[(GHC.Types.Int, GHC.Types.Int)]"
69:14-69:17::_ :: "([GHC.Types.Int] -> (GHC.Types.Int, GHC.Types.Int))\n-> x3:[[GHC.Types.Int]]\n-> {v : [(GHC.Types.Int, GHC.Types.Int)] | len v == len x3}"
69:19-69:36::lq_anf__d1V6 :: "[GHC.Types.Int] -> (GHC.Types.Int, GHC.Types.Int)"
69:30-69:36::GHC.Tuple.(,) :: "forall a b <p2 :: a b -> Prop>.\nx1:a\n-> x2:{VV : b<p2 x1> | true}\n-> {v : (a, b)<\\x6 VV -> p2 x6> | fst v == x1 && x_Tuple22 v == x2 && snd v == x2 && x_Tuple21 v == x1}"
69:31-69:32::x :: "{v : GHC.Types.Int | v == x}"
69:34-69:35::y :: "{v : GHC.Types.Int | v == y}"
69:37-69:38::_ :: "([[GHC.Types.Int]] -> [(GHC.Types.Int, GHC.Types.Int)])\n-> ([GHC.Types.Char] -> [[GHC.Types.Int]])\n-> [GHC.Types.Char]\n-> exists [[[GHC.Types.Int]]].[(GHC.Types.Int, GHC.Types.Int)]"
69:39-69:42::_ :: "([[GHC.Types.Char]] -> [GHC.Types.Int])\n-> x3:[[[GHC.Types.Char]]]\n-> {v : [[GHC.Types.Int]] | len v == len x3}"
69:44-69:47::_ :: "([GHC.Types.Char] -> GHC.Types.Int)\n-> x3:[[GHC.Types.Char]] -> {v : [GHC.Types.Int] | len v == len x3}"
69:49-69:53::lq_anf__d1V8 :: "[GHC.Types.Char] -> GHC.Types.Int"
69:68-69:69::_ :: "([[[GHC.Types.Char]]] -> [[GHC.Types.Int]])\n-> ([GHC.Types.Char] -> [[[GHC.Types.Char]]])\n-> [GHC.Types.Char]\n-> exists [[[[GHC.Types.Char]]]].[[GHC.Types.Int]]"
69:70-69:73::_ :: "([GHC.Types.Char] -> [[GHC.Types.Char]])\n-> x3:[[GHC.Types.Char]]\n-> {v : [[[GHC.Types.Char]]] | len v == len x3}"
69:74-69:79::Data.List.words :: "[GHC.Types.Char] -> [[GHC.Types.Char]]"
69:79-69:80::_ :: "([[GHC.Types.Char]] -> [[[GHC.Types.Char]]])\n-> ([GHC.Types.Char] -> [[GHC.Types.Char]])\n-> [GHC.Types.Char]\n-> exists [[[GHC.Types.Char]]].[[[GHC.Types.Char]]]"
69:81-69:86::Data.List.lines :: "[GHC.Types.Char] -> [[GHC.Types.Char]]"
69:87-69:88::_ :: "([GHC.Types.Char] -> [(GHC.Types.Int, GHC.Types.Int)])\n-> [GHC.Types.Char] -> [(GHC.Types.Int, GHC.Types.Int)]"
69:89-69:96::content :: "{v : [GHC.Types.Char] | v == content && len v >= 0}"
70:5-70:8::ans :: "GHC.Types.Double"
70:11-70:16::_ :: "[(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Double"
70:17-70:23::points :: "{v : [(GHC.Types.Int, GHC.Types.Int)] | v == points && len v >= 0}"
71:3-71:9::_ :: "[GHC.Types.Char] -> GHC.Types.Double -> (GHC.Types.IO ())"
71:10-71:18::lq_anf__d1Vf :: "{v : [GHC.Types.Char] | len v >= 0}"
71:19-71:22::ans :: "{v : GHC.Types.Double | v == ans}"